From fb8d3df166087b29c98dd08e92c5d241d3e21396 Mon Sep 17 00:00:00 2001
From: Tiago Vignatti <tiago.vignatti@intel.com>
Date: Tue, 30 Jul 2013 16:09:44 +0300
Subject: [PATCH 04/11] content: Implement Ozone to WebKit input conversion

---
 .../browser/renderer_host/web_input_event_aura.cc  |    2 +-
 .../renderer_host/web_input_event_auraozone.cc     |  172 ++++++++++++++++++++
 content/content_browser.gypi                       |    1 +
 3 files changed, 174 insertions(+), 1 deletion(-)
 create mode 100644 content/browser/renderer_host/web_input_event_auraozone.cc

diff --git a/content/browser/renderer_host/web_input_event_aura.cc b/content/browser/renderer_host/web_input_event_aura.cc
index 8931f1f..89ce747 100644
--- a/content/browser/renderer_host/web_input_event_aura.cc
+++ b/content/browser/renderer_host/web_input_event_aura.cc
@@ -20,7 +20,7 @@ WebKit::WebKeyboardEvent MakeWebKeyboardEventFromNativeEvent(
     base::NativeEvent native_event);
 WebKit::WebGestureEvent MakeWebGestureEventFromNativeEvent(
     base::NativeEvent native_event);
-#elif defined(USE_X11)
+#elif defined(USE_X11) || defined(USE_OZONE)
 WebKit::WebMouseWheelEvent MakeWebMouseWheelEventFromAuraEvent(
     ui::ScrollEvent* event);
 WebKit::WebKeyboardEvent MakeWebKeyboardEventFromAuraEvent(
diff --git a/content/browser/renderer_host/web_input_event_auraozone.cc b/content/browser/renderer_host/web_input_event_auraozone.cc
new file mode 100644
index 0000000..4dbc94d
--- /dev/null
+++ b/content/browser/renderer_host/web_input_event_auraozone.cc
@@ -0,0 +1,172 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "content/browser/renderer_host/web_input_event_aura.h"
+
+#include <cstdlib>
+
+#include "base/event_types.h"
+#include "base/logging.h"
+#include "content/browser/renderer_host/ui_events_helper.h"
+#include "ui/base/events/event.h"
+#include "ui/base/events/event_constants.h"
+#include "ui/base/events/event_utils.h"
+#include "ui/base/keycodes/keyboard_codes.h"
+
+namespace content {
+
+// chromium WebKit does not provide a WebInputEventFactory for Ozone, so we have
+// to do the work here ourselves.
+
+namespace {
+
+// From
+// third_party/WebKit/Source/WebKit/chromium/src/gtk/WebInputEventFactory.cpp:
+WebKit::WebUChar GetControlCharacter(int windows_key_code, bool shift) {
+  if (windows_key_code >= ui::VKEY_A &&
+    windows_key_code <= ui::VKEY_Z) {
+    // ctrl-A ~ ctrl-Z map to \x01 ~ \x1A
+    return windows_key_code - ui::VKEY_A + 1;
+  }
+  if (shift) {
+    // following graphics chars require shift key to input.
+    switch (windows_key_code) {
+      // ctrl-@ maps to \x00 (Null byte)
+      case ui::VKEY_2:
+        return 0;
+      // ctrl-^ maps to \x1E (Record separator, Information separator two)
+      case ui::VKEY_6:
+        return 0x1E;
+      // ctrl-_ maps to \x1F (Unit separator, Information separator one)
+      case ui::VKEY_OEM_MINUS:
+        return 0x1F;
+      // Returns 0 for all other keys to avoid inputting unexpected chars.
+      default:
+        break;
+    }
+  } else {
+    switch (windows_key_code) {
+      // ctrl-[ maps to \x1B (Escape)
+      case ui::VKEY_OEM_4:
+        return 0x1B;
+      // ctrl-\ maps to \x1C (File separator, Information separator four)
+      case ui::VKEY_OEM_5:
+        return 0x1C;
+      // ctrl-] maps to \x1D (Group separator, Information separator three)
+      case ui::VKEY_OEM_6:
+        return 0x1D;
+      // ctrl-Enter maps to \x0A (Line feed)
+      case ui::VKEY_RETURN:
+        return 0x0A;
+      // Returns 0 for all other keys to avoid inputting unexpected chars.
+      default:
+        break;
+    }
+  }
+  return 0;
+}
+
+}  // namespace
+
+WebKit::WebMouseWheelEvent MakeWebMouseWheelEventFromAuraEvent(
+    ui::ScrollEvent* event) {
+  WebKit::WebMouseWheelEvent webkit_event;
+
+  webkit_event.type = WebKit::WebInputEvent::MouseWheel;
+  webkit_event.button = WebKit::WebMouseEvent::ButtonNone;
+  webkit_event.modifiers = EventFlagsToWebEventModifiers(event->flags());
+  webkit_event.timeStampSeconds = event->time_stamp().InSecondsF();
+  webkit_event.hasPreciseScrollingDeltas = true;
+  webkit_event.deltaX = event->x_offset();
+  if (event->x_offset_ordinal() != 0.f && event->x_offset() != 0.f) {
+    webkit_event.accelerationRatioX =
+        event->x_offset_ordinal() / event->x_offset();
+  }
+  webkit_event.wheelTicksX = webkit_event.deltaX / kPixelsPerTick;
+  webkit_event.deltaY = event->y_offset();
+  webkit_event.wheelTicksY = webkit_event.deltaY / kPixelsPerTick;
+  if (event->y_offset_ordinal() != 0.f && event->y_offset() != 0.f) {
+    webkit_event.accelerationRatioY =
+        event->y_offset_ordinal() / event->y_offset();
+  }
+
+  return webkit_event;
+}
+
+// NOTE: ui::ScrollEvent instances come from the touchpad.
+WebKit::WebGestureEvent MakeWebGestureEventFromAuraEvent(
+    ui::ScrollEvent* event) {
+  WebKit::WebGestureEvent webkit_event;
+
+  switch (event->type()) {
+    case ui::ET_SCROLL_FLING_START:
+      webkit_event.type = WebKit::WebInputEvent::GestureFlingStart;
+      webkit_event.data.flingStart.velocityX = event->x_offset();
+      webkit_event.data.flingStart.velocityY = event->y_offset();
+      break;
+    case ui::ET_SCROLL_FLING_CANCEL:
+      webkit_event.type = WebKit::WebInputEvent::GestureFlingCancel;
+      break;
+    case ui::ET_SCROLL:
+      NOTREACHED() << "Invalid gesture type: " << event->type();
+      break;
+    default:
+      NOTREACHED() << "Unknown gesture type: " << event->type();
+  }
+
+  webkit_event.sourceDevice = WebKit::WebGestureEvent::Touchpad;
+  webkit_event.modifiers = EventFlagsToWebEventModifiers(event->flags());
+  webkit_event.timeStampSeconds = event->time_stamp().InSecondsF();
+
+  return webkit_event;
+}
+
+WebKit::WebKeyboardEvent MakeWebKeyboardEventFromAuraEvent(
+    ui::KeyEvent* event) {
+  base::NativeEvent native_event = event->native_event();
+  ui::EventType type = ui::EventTypeFromNative(native_event);
+  WebKit::WebKeyboardEvent webkit_event;
+
+  webkit_event.timeStampSeconds = event->time_stamp().InSecondsF();
+  webkit_event.modifiers = EventFlagsToWebEventModifiers(event->flags());
+
+  switch (type) {
+    case ui::ET_KEY_PRESSED:
+      webkit_event.type = event->is_char() ? WebKit::WebInputEvent::Char :
+          WebKit::WebInputEvent::RawKeyDown;
+      break;
+    case ui::ET_KEY_RELEASED:
+      webkit_event.type = WebKit::WebInputEvent::KeyUp;
+      break;
+    default:
+      NOTREACHED();
+  }
+
+  if (webkit_event.modifiers & WebKit::WebInputEvent::AltKey)
+    webkit_event.isSystemKey = true;
+
+  wchar_t character = ui::KeyboardCodeFromNative(native_event);
+  webkit_event.windowsKeyCode = character;
+  webkit_event.nativeKeyCode = character;
+
+  if (webkit_event.windowsKeyCode == ui::VKEY_RETURN)
+    webkit_event.unmodifiedText[0] = '\r';
+  else
+    webkit_event.unmodifiedText[0] = character;
+
+  if (webkit_event.modifiers & WebKit::WebInputEvent::ControlKey) {
+    webkit_event.text[0] =
+        GetControlCharacter(
+            webkit_event.windowsKeyCode,
+            webkit_event.modifiers & WebKit::WebInputEvent::ShiftKey);
+  } else {
+    webkit_event.text[0] = webkit_event.unmodifiedText[0];
+  }
+
+  webkit_event.setKeyIdentifierFromWindowsKeyCode();
+
+  return webkit_event;
+}
+
+}  // namespace content
diff --git a/content/content_browser.gypi b/content/content_browser.gypi
index ce11fc7..a09a380 100644
--- a/content/content_browser.gypi
+++ b/content/content_browser.gypi
@@ -987,6 +987,7 @@
     'browser/renderer_host/ui_events_helper.h',
     'browser/renderer_host/web_input_event_aura.cc',
     'browser/renderer_host/web_input_event_aura.h',
+    'browser/renderer_host/web_input_event_auraozone.cc',
     'browser/renderer_host/web_input_event_aurawin.cc',
     'browser/renderer_host/web_input_event_aurax11.cc',
     'browser/renderer_host/webmenurunner_mac.h',
-- 
1.7.9.5

