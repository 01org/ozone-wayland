From 467e4756e6fb2e04dcd4aa3d294a6009260db775 Mon Sep 17 00:00:00 2001
From: Kondapally Kalyan <kalyan.kondapally@intel.com>
Date: Thu, 15 May 2014 21:58:55 +0300
Subject: [PATCH 1/5] Rebase CL 205433002

---
 .../compositor/software_output_device_ozone.cc     |   26 +++----
 .../compositor/software_output_device_ozone.h      |    6 +-
 ui/aura/window_tree_host_ozone.cc                  |    2 -
 ui/gfx/gfx.gyp                                     |    3 +
 ui/gfx/ozone/dri/dri_surface_factory.cc            |   51 ++++++++++---
 ui/gfx/ozone/dri/dri_surface_factory.h             |   15 ++--
 ui/gfx/ozone/dri/dri_surface_factory_unittest.cc   |   16 ++--
 ui/gfx/ozone/impl/file_surface_factory.cc          |   78 ++++++++++----------
 ui/gfx/ozone/impl/file_surface_factory.h           |   11 +--
 ui/gfx/ozone/surface_factory_ozone.cc              |   12 ++-
 ui/gfx/ozone/surface_factory_ozone.h               |   38 ++--------
 ui/gfx/ozone/surface_ozone.h                       |   70 ++++++++++++++++++
 ui/gfx/ozone/surface_ozone_base.cc                 |   45 +++++++++++
 ui/gfx/ozone/surface_ozone_base.h                  |   41 ++++++++++
 ui/gl/gl_surface_ozone.cc                          |   42 ++++++++---
 15 files changed, 319 insertions(+), 137 deletions(-)
 create mode 100644 ui/gfx/ozone/surface_ozone.h
 create mode 100644 ui/gfx/ozone/surface_ozone_base.cc
 create mode 100644 ui/gfx/ozone/surface_ozone_base.h

diff --git a/content/browser/compositor/software_output_device_ozone.cc b/content/browser/compositor/software_output_device_ozone.cc
index ad7d031..44b5e1b 100644
--- a/content/browser/compositor/software_output_device_ozone.cc
+++ b/content/browser/compositor/software_output_device_ozone.cc
@@ -6,24 +6,25 @@
 #include "third_party/skia/include/core/SkDevice.h"
 #include "ui/compositor/compositor.h"
 #include "ui/gfx/ozone/surface_factory_ozone.h"
+#include "ui/gfx/ozone/surface_ozone.h"
 #include "ui/gfx/skia_util.h"
 #include "ui/gfx/vsync_provider.h"

 namespace content {

 SoftwareOutputDeviceOzone::SoftwareOutputDeviceOzone(ui::Compositor* compositor)
-    : compositor_(compositor), realized_widget_(gfx::kNullAcceleratedWidget) {
+    : compositor_(compositor) {
   gfx::SurfaceFactoryOzone* factory = gfx::SurfaceFactoryOzone::GetInstance();

   if (factory->InitializeHardware() != gfx::SurfaceFactoryOzone::INITIALIZED)
     LOG(FATAL) << "Failed to initialize hardware in OZONE";

-  realized_widget_ = factory->RealizeAcceleratedWidget(compositor_->widget());
+  surface_ozone_ = factory->CreateSurfaceForWidget(compositor_->widget());

-  if (realized_widget_ == gfx::kNullAcceleratedWidget)
-    LOG(FATAL) << "Failed to get a realized AcceleratedWidget";
+  if (!surface_ozone_->InitializeCanvas())
+    LOG(FATAL) << "Failed to initialize canvas";

-  vsync_provider_ = factory->CreateVSyncProvider(realized_widget_);
+  vsync_provider_ = surface_ozone_->CreateVSyncProvider();
 }

 SoftwareOutputDeviceOzone::~SoftwareOutputDeviceOzone() {
@@ -34,18 +35,16 @@ void SoftwareOutputDeviceOzone::Resize(const gfx::Size& viewport_size) {
     return;

   viewport_size_ = viewport_size;
-  gfx::Rect bounds(viewport_size_);

-  gfx::SurfaceFactoryOzone* factory = gfx::SurfaceFactoryOzone::GetInstance();
-  factory->AttemptToResizeAcceleratedWidget(compositor_->widget(),
-                                            bounds);
-
-  canvas_ = skia::SharePtr(factory->GetCanvasForWidget(realized_widget_));
+  surface_ozone_->ResizeCanvas(viewport_size_);
 }

 SkCanvas* SoftwareOutputDeviceOzone::BeginPaint(const gfx::Rect& damage_rect) {
   DCHECK(gfx::Rect(viewport_size_).Contains(damage_rect));

+  // Get canvas for next frame.
+  canvas_ = surface_ozone_->GetCanvas();
+
   canvas_->clipRect(gfx::RectToSkRect(damage_rect), SkRegion::kReplace_Op);
   // Save the current state so we can restore once we're done drawing. This is
   // saved after the clip since we want to keep the clip information after we're
@@ -63,9 +62,8 @@ void SoftwareOutputDeviceOzone::EndPaint(cc::SoftwareFrameData* frame_data) {
   if (damage_rect_.IsEmpty())
     return;

-  bool scheduled = gfx::SurfaceFactoryOzone::GetInstance()->SchedulePageFlip(
-      compositor_->widget());
-  DCHECK(scheduled) << "Failed to schedule pageflip";
+  bool scheduled = surface_ozone_->PresentCanvas();
+  DCHECK(scheduled) << "Failed to present canvas";
 }

 }  // namespace content
diff --git a/content/browser/compositor/software_output_device_ozone.h b/content/browser/compositor/software_output_device_ozone.h
index befd395..46014e6 100644
--- a/content/browser/compositor/software_output_device_ozone.h
+++ b/content/browser/compositor/software_output_device_ozone.h
@@ -13,6 +13,10 @@ namespace ui {
 class Compositor;
 }

+namespace gfx {
+class SurfaceOzone;
+}
+
 namespace content {

 // Ozone implementation which relies on software rendering. Ozone will present
@@ -31,7 +35,7 @@ class CONTENT_EXPORT SoftwareOutputDeviceOzone
  private:
   ui::Compositor* compositor_;

-  gfx::AcceleratedWidget realized_widget_;
+  scoped_ptr<gfx::SurfaceOzone> surface_ozone_;

   DISALLOW_COPY_AND_ASSIGN(SoftwareOutputDeviceOzone);
 };
diff --git a/ui/aura/window_tree_host_ozone.cc b/ui/aura/window_tree_host_ozone.cc
index cec4708..013fae8 100644
--- a/ui/aura/window_tree_host_ozone.cc
+++ b/ui/aura/window_tree_host_ozone.cc
@@ -26,8 +26,6 @@ WindowTreeHostOzone::WindowTreeHostOzone(const gfx::Rect& bounds)
       gfx::SurfaceFactoryOzone::GetInstance();
   widget_ = surface_factory->GetAcceleratedWidget();

-  surface_factory->AttemptToResizeAcceleratedWidget(widget_, bounds_);
-
   base::MessagePumpOzone::Current()->AddDispatcherForRootWindow(this);
   CreateCompositor(GetAcceleratedWidget());
 }
diff --git a/ui/gfx/gfx.gyp b/ui/gfx/gfx.gyp
index b712b0b..4235c39 100644
--- a/ui/gfx/gfx.gyp
+++ b/ui/gfx/gfx.gyp
@@ -218,6 +218,9 @@
         'ozone/impl/file_surface_factory.h',
         'ozone/surface_factory_ozone.cc',
         'ozone/surface_factory_ozone.h',
+        'ozone/surface_ozone_base.cc',
+        'ozone/surface_ozone_base.h',
+        'ozone/surface_ozone.h',
         'ozone/overlay_candidates_ozone.cc',
         'ozone/overlay_candidates_ozone.h',
         'pango_util.cc',
diff --git a/ui/gfx/ozone/dri/dri_surface_factory.cc b/ui/gfx/ozone/dri/dri_surface_factory.cc
index 661944a..a6be37f 100644
--- a/ui/gfx/ozone/dri/dri_surface_factory.cc
+++ b/ui/gfx/ozone/dri/dri_surface_factory.cc
@@ -17,6 +17,7 @@
 #include "ui/gfx/ozone/dri/dri_vsync_provider.h"
 #include "ui/gfx/ozone/dri/dri_wrapper.h"
 #include "ui/gfx/ozone/dri/hardware_display_controller.h"
+#include "ui/gfx/ozone/surface_ozone_base.h"

 namespace gfx {

@@ -114,6 +115,37 @@ void UpdateCursorImage(DriSurface* cursor, const SkBitmap& image) {
   canvas->drawBitmapRectToRect(image, &damage, damage);
 }

+// Adapter from SurfaceOzone to DriSurfaceFactory
+//
+// This class is derived from SurfaceOzone and owned by the compositor.
+//
+// For DRI the hadware surface & canvas are owned by the platform, so
+// the compositor merely owns this proxy object.
+//
+// TODO(spang): Should the compositor own any bits of the DriSurface?
+class DriSurfaceAdapter : public SurfaceOzoneBase {
+ public:
+  DriSurfaceAdapter(gfx::AcceleratedWidget w, DriSurfaceFactory* dri)
+      : widget_(w), dri_(dri) {}
+  virtual ~DriSurfaceAdapter() {}
+
+  // SurfaceOzone:
+  virtual bool InitializeCanvas() OVERRIDE { return true; }
+  virtual skia::RefPtr<SkCanvas> GetCanvas() OVERRIDE {
+    return skia::SharePtr(dri_->GetCanvasForWidget(widget_));
+  }
+  virtual bool PresentCanvas() OVERRIDE {
+    return dri_->SchedulePageFlip(widget_);
+  }
+  virtual scoped_ptr<gfx::VSyncProvider> CreateVSyncProvider() OVERRIDE {
+    return dri_->CreateVSyncProvider(widget_);
+  }
+
+ private:
+  gfx::AcceleratedWidget widget_;
+  DriSurfaceFactory* dri_;
+};
+
 }  // namespace

 DriSurfaceFactory::DriSurfaceFactory()
@@ -176,7 +208,7 @@ gfx::AcceleratedWidget DriSurfaceFactory::GetAcceleratedWidget() {
   return kDefaultWidgetHandle;
 }

-gfx::AcceleratedWidget DriSurfaceFactory::RealizeAcceleratedWidget(
+scoped_ptr<SurfaceOzone> DriSurfaceFactory::CreateSurfaceForWidget(
     gfx::AcceleratedWidget w) {
   CHECK(state_ == INITIALIZED);
   // TODO(dnicoara) Once we can handle multiple displays this needs to be
@@ -190,7 +222,7 @@ gfx::AcceleratedWidget DriSurfaceFactory::RealizeAcceleratedWidget(
   // hardware display.
   if (!InitializeControllerForPrimaryDisplay(drm_.get(), controller_.get())) {
     LOG(ERROR) << "Failed to initialize controller";
-    return gfx::kNullAcceleratedWidget;
+    return scoped_ptr<SurfaceOzone>();
   }

   // Create a surface suitable for the current controller.
@@ -200,7 +232,7 @@ gfx::AcceleratedWidget DriSurfaceFactory::RealizeAcceleratedWidget(

   if (!surface->Initialize()) {
     LOG(ERROR) << "Failed to initialize surface";
-    return gfx::kNullAcceleratedWidget;
+    return scoped_ptr<SurfaceOzone>();
   }

   // Bind the surface to the controller. This will register the backing buffers
@@ -208,13 +240,13 @@ gfx::AcceleratedWidget DriSurfaceFactory::RealizeAcceleratedWidget(
   // takes ownership of the surface.
   if (!controller_->BindSurfaceToController(surface.Pass())) {
     LOG(ERROR) << "Failed to bind surface to controller";
-    return gfx::kNullAcceleratedWidget;
+    return scoped_ptr<SurfaceOzone>();
   }

   // Initial cursor set.
   ResetCursor();

-  return reinterpret_cast<gfx::AcceleratedWidget>(controller_->get_surface());
+  return make_scoped_ptr<SurfaceOzone>(new DriSurfaceAdapter(w, this));
 }

 bool DriSurfaceFactory::LoadEGLGLES2Bindings(
@@ -223,12 +255,6 @@ bool DriSurfaceFactory::LoadEGLGLES2Bindings(
   return false;
 }

-bool DriSurfaceFactory::AttemptToResizeAcceleratedWidget(
-    gfx::AcceleratedWidget w,
-    const gfx::Rect& bounds) {
-  return false;
-}
-
 bool DriSurfaceFactory::SchedulePageFlip(gfx::AcceleratedWidget w) {
   CHECK(state_ == INITIALIZED);
   // TODO(dnicoara) Change this CHECK once we're running with the threaded
@@ -264,7 +290,8 @@ bool DriSurfaceFactory::SchedulePageFlip(gfx::AcceleratedWidget w) {
 SkCanvas* DriSurfaceFactory::GetCanvasForWidget(
     gfx::AcceleratedWidget w) {
   CHECK(state_ == INITIALIZED);
-  return reinterpret_cast<DriSurface*>(w)->GetDrawableForWidget();
+  CHECK_EQ(kDefaultWidgetHandle, w);
+  return controller_->get_surface()->GetDrawableForWidget();
 }

 scoped_ptr<gfx::VSyncProvider> DriSurfaceFactory::CreateVSyncProvider(
diff --git a/ui/gfx/ozone/dri/dri_surface_factory.h b/ui/gfx/ozone/dri/dri_surface_factory.h
index 3b958bd..34f2bdd 100644
--- a/ui/gfx/ozone/dri/dri_surface_factory.h
+++ b/ui/gfx/ozone/dri/dri_surface_factory.h
@@ -8,12 +8,14 @@
 #include "base/memory/scoped_ptr.h"
 #include "third_party/skia/include/core/SkBitmap.h"
 #include "ui/gfx/ozone/surface_factory_ozone.h"
+#include "ui/gfx/ozone/surface_ozone.h"

 namespace gfx {

 class DriSurface;
 class DriWrapper;
 class HardwareDisplayController;
+class SurfaceOzone;

 // SurfaceFactoryOzone implementation on top of DRM/KMS using dumb buffers.
 // This implementation is used in conjunction with the software rendering
@@ -27,23 +29,20 @@ class GFX_EXPORT DriSurfaceFactory : public SurfaceFactoryOzone {
   virtual void ShutdownHardware() OVERRIDE;

   virtual gfx::AcceleratedWidget GetAcceleratedWidget() OVERRIDE;
-  virtual gfx::AcceleratedWidget RealizeAcceleratedWidget(
+
+  virtual scoped_ptr<SurfaceOzone> CreateSurfaceForWidget(
       gfx::AcceleratedWidget w) OVERRIDE;

   virtual bool LoadEGLGLES2Bindings(
       AddGLLibraryCallback add_gl_library,
       SetGLGetProcAddressProcCallback set_gl_get_proc_address) OVERRIDE;

-  virtual bool AttemptToResizeAcceleratedWidget(
-      gfx::AcceleratedWidget w,
-      const gfx::Rect& bounds) OVERRIDE;
-
-  virtual bool SchedulePageFlip(gfx::AcceleratedWidget w) OVERRIDE;
+  virtual bool SchedulePageFlip(gfx::AcceleratedWidget w);

-  virtual SkCanvas* GetCanvasForWidget(gfx::AcceleratedWidget w) OVERRIDE;
+  virtual SkCanvas* GetCanvasForWidget(gfx::AcceleratedWidget w);

   virtual scoped_ptr<gfx::VSyncProvider> CreateVSyncProvider(
-      gfx::AcceleratedWidget w) OVERRIDE;
+      gfx::AcceleratedWidget w);

   void SetHardwareCursor(AcceleratedWidget window,
                          const SkBitmap& image,
diff --git a/ui/gfx/ozone/dri/dri_surface_factory_unittest.cc b/ui/gfx/ozone/dri/dri_surface_factory_unittest.cc
index b0e108e..1c1fb3f 100644
--- a/ui/gfx/ozone/dri/dri_surface_factory_unittest.cc
+++ b/ui/gfx/ozone/dri/dri_surface_factory_unittest.cc
@@ -263,7 +263,7 @@ TEST_F(DriSurfaceFactoryTest, FailSurfaceInitialization) {
   gfx::AcceleratedWidget w = factory_->GetAcceleratedWidget();
   EXPECT_EQ(kDefaultWidgetHandle, w);

-  EXPECT_EQ(gfx::kNullAcceleratedWidget, factory_->RealizeAcceleratedWidget(w));
+  EXPECT_FALSE(factory_->CreateSurfaceForWidget(w));
 }

 TEST_F(DriSurfaceFactoryTest, FailBindingSurfaceToController) {
@@ -275,7 +275,7 @@ TEST_F(DriSurfaceFactoryTest, FailBindingSurfaceToController) {
   gfx::AcceleratedWidget w = factory_->GetAcceleratedWidget();
   EXPECT_EQ(kDefaultWidgetHandle, w);

-  EXPECT_EQ(gfx::kNullAcceleratedWidget, factory_->RealizeAcceleratedWidget(w));
+  EXPECT_FALSE(factory_->CreateSurfaceForWidget(w));
 }

 TEST_F(DriSurfaceFactoryTest, SuccessfulWidgetRealization) {
@@ -285,7 +285,7 @@ TEST_F(DriSurfaceFactoryTest, SuccessfulWidgetRealization) {
   gfx::AcceleratedWidget w = factory_->GetAcceleratedWidget();
   EXPECT_EQ(kDefaultWidgetHandle, w);

-  EXPECT_NE(gfx::kNullAcceleratedWidget, factory_->RealizeAcceleratedWidget(w));
+  EXPECT_TRUE(factory_->CreateSurfaceForWidget(w));
 }

 TEST_F(DriSurfaceFactoryTest, FailSchedulePageFlip) {
@@ -297,7 +297,8 @@ TEST_F(DriSurfaceFactoryTest, FailSchedulePageFlip) {
   gfx::AcceleratedWidget w = factory_->GetAcceleratedWidget();
   EXPECT_EQ(kDefaultWidgetHandle, w);

-  EXPECT_NE(gfx::kNullAcceleratedWidget, factory_->RealizeAcceleratedWidget(w));
+  scoped_ptr<gfx::SurfaceOzone> surf = factory_->CreateSurfaceForWidget(w);
+  EXPECT_TRUE(surf);

   EXPECT_FALSE(factory_->SchedulePageFlip(w));
 }
@@ -309,7 +310,8 @@ TEST_F(DriSurfaceFactoryTest, SuccessfulSchedulePageFlip) {
   gfx::AcceleratedWidget w = factory_->GetAcceleratedWidget();
   EXPECT_EQ(kDefaultWidgetHandle, w);

-  EXPECT_NE(gfx::kNullAcceleratedWidget, factory_->RealizeAcceleratedWidget(w));
+  scoped_ptr<gfx::SurfaceOzone> surf = factory_->CreateSurfaceForWidget(w);
+  EXPECT_TRUE(surf);

   EXPECT_TRUE(factory_->SchedulePageFlip(w));
 }
@@ -320,7 +322,9 @@ TEST_F(DriSurfaceFactoryTest, SetCursorImage) {

   gfx::AcceleratedWidget w = factory_->GetAcceleratedWidget();
   EXPECT_EQ(kDefaultWidgetHandle, w);
-  EXPECT_NE(gfx::kNullAcceleratedWidget, factory_->RealizeAcceleratedWidget(w));
+
+  scoped_ptr<gfx::SurfaceOzone> surf = factory_->CreateSurfaceForWidget(w);
+  EXPECT_TRUE(surf);

   SkBitmap image;
   SkImageInfo info = SkImageInfo::Make(
diff --git a/ui/gfx/ozone/impl/file_surface_factory.cc b/ui/gfx/ozone/impl/file_surface_factory.cc
index 7083376..c42be60 100644
--- a/ui/gfx/ozone/impl/file_surface_factory.cc
+++ b/ui/gfx/ozone/impl/file_surface_factory.cc
@@ -12,8 +12,12 @@
 #include "third_party/skia/include/core/SkBitmapDevice.h"
 #include "third_party/skia/include/core/SkDevice.h"
 #include "ui/gfx/codec/png_codec.h"
+#include "ui/gfx/ozone/surface_ozone_base.h"
+#include "ui/gfx/skia_util.h"
 #include "ui/gfx/vsync_provider.h"

+namespace gfx {
+
 namespace {

 void WriteDataToFile(const base::FilePath& location,
@@ -25,9 +29,42 @@ void WriteDataToFile(const base::FilePath& location,
                   png_data.size());
 }

-}
+class FileSurface : public SurfaceOzoneBase {
+ public:
+  FileSurface(const base::FilePath& location) : location_(location) {}
+  virtual ~FileSurface() {}

-namespace gfx {
+  bool InitializeCanvas() OVERRIDE { return true; }
+
+  bool ResizeCanvas(const Size& viewport_size) OVERRIDE {
+    SkImageInfo info = SkImageInfo::MakeN32Premul(viewport_size.width(),
+                                                  viewport_size.height());
+    device_ = skia::AdoptRef(SkBitmapDevice::Create(info));
+    canvas_ = skia::AdoptRef(new SkCanvas(device_.get()));
+    return true;
+  }
+
+  skia::RefPtr<SkCanvas> GetCanvas() OVERRIDE { return canvas_; }
+
+  bool PresentCanvas() OVERRIDE {
+    SkBitmap bitmap;
+    bitmap.setConfig(
+        SkBitmap::kARGB_8888_Config, device_->width(), device_->height());
+
+    if (canvas_->readPixels(&bitmap, 0, 0)) {
+      base::WorkerPool::PostTask(
+          FROM_HERE, base::Bind(&WriteDataToFile, location_, bitmap), true);
+    }
+    return true;
+  }
+
+ private:
+  base::FilePath location_;
+  skia::RefPtr<SkBitmapDevice> device_;
+  skia::RefPtr<SkCanvas> canvas_;
+};
+
+}  // namespace

 FileSurfaceFactory::FileSurfaceFactory(
     const base::FilePath& dump_location)
@@ -51,9 +88,9 @@ AcceleratedWidget FileSurfaceFactory::GetAcceleratedWidget() {
   return 1;
 }

-AcceleratedWidget FileSurfaceFactory::RealizeAcceleratedWidget(
+scoped_ptr<SurfaceOzone> FileSurfaceFactory::CreateSurfaceForWidget(
     AcceleratedWidget widget) {
-  return 1;
+  return make_scoped_ptr<SurfaceOzone>(new FileSurface(location_));
 }

 bool FileSurfaceFactory::LoadEGLGLES2Bindings(
@@ -62,37 +99,4 @@ bool FileSurfaceFactory::LoadEGLGLES2Bindings(
   return false;
 }

-bool FileSurfaceFactory::AttemptToResizeAcceleratedWidget(
-    AcceleratedWidget widget,
-    const Rect& bounds) {
-  SkImageInfo info = SkImageInfo::MakeN32Premul(bounds.width(),
-                                                bounds.height());
-  device_ = skia::AdoptRef(SkBitmapDevice::Create(info));
-  canvas_ = skia::AdoptRef(new SkCanvas(device_.get()));
-  return true;
-}
-
-bool FileSurfaceFactory::SchedulePageFlip(AcceleratedWidget widget) {
-  SkBitmap bitmap;
-  bitmap.setConfig(SkBitmap::kARGB_8888_Config,
-                   device_->width(),
-                   device_->height());
-
-  if (canvas_->readPixels(&bitmap, 0, 0)) {
-    base::WorkerPool::PostTask(FROM_HERE,
-        base::Bind(&WriteDataToFile, location_, bitmap),
-        true);
-  }
-  return true;
-}
-
-SkCanvas* FileSurfaceFactory::GetCanvasForWidget(AcceleratedWidget w) {
-  return canvas_.get();
-}
-
-scoped_ptr<VSyncProvider> FileSurfaceFactory::CreateVSyncProvider(
-    AcceleratedWidget w) {
-  return scoped_ptr<VSyncProvider>();
-}
-
 }  // namespace gfx
diff --git a/ui/gfx/ozone/impl/file_surface_factory.h b/ui/gfx/ozone/impl/file_surface_factory.h
index b3b2cc0..11f937c 100644
--- a/ui/gfx/ozone/impl/file_surface_factory.h
+++ b/ui/gfx/ozone/impl/file_surface_factory.h
@@ -9,7 +9,6 @@
 #include "base/memory/scoped_ptr.h"
 #include "ui/gfx/native_widget_types.h"
 #include "ui/gfx/ozone/surface_factory_ozone.h"
-#include "ui/gfx/skia_util.h"

 class SkBitmapDevice;
 class SkCanvas;
@@ -26,21 +25,13 @@ class GFX_EXPORT FileSurfaceFactory : public SurfaceFactoryOzone {
   virtual HardwareState InitializeHardware() OVERRIDE;
   virtual void ShutdownHardware() OVERRIDE;
   virtual AcceleratedWidget GetAcceleratedWidget() OVERRIDE;
-  virtual AcceleratedWidget RealizeAcceleratedWidget(
+  virtual scoped_ptr<SurfaceOzone> CreateSurfaceForWidget(
       AcceleratedWidget widget) OVERRIDE;
   virtual bool LoadEGLGLES2Bindings(
       AddGLLibraryCallback add_gl_library,
       SetGLGetProcAddressProcCallback set_gl_get_proc_address) OVERRIDE;
-  virtual bool AttemptToResizeAcceleratedWidget(AcceleratedWidget widget,
-                                                const Rect& bounds) OVERRIDE;
-  virtual bool SchedulePageFlip(AcceleratedWidget widget) OVERRIDE;
-  virtual SkCanvas* GetCanvasForWidget(AcceleratedWidget widget) OVERRIDE;
-  virtual scoped_ptr<VSyncProvider> CreateVSyncProvider(
-      AcceleratedWidget widget) OVERRIDE;

   base::FilePath location_;
-  skia::RefPtr<SkBitmapDevice> device_;
-  skia::RefPtr<SkCanvas> canvas_;

   DISALLOW_COPY_AND_ASSIGN(FileSurfaceFactory);
 };
diff --git a/ui/gfx/ozone/surface_factory_ozone.cc b/ui/gfx/ozone/surface_factory_ozone.cc
index 8690db4..a678fa8 100644
--- a/ui/gfx/ozone/surface_factory_ozone.cc
+++ b/ui/gfx/ozone/surface_factory_ozone.cc
@@ -7,7 +7,7 @@
 #include <stdlib.h>

 #include "base/command_line.h"
-#include "ui/gfx/vsync_provider.h"
+#include "ui/gfx/ozone/surface_ozone.h"

 namespace gfx {

@@ -33,12 +33,10 @@ intptr_t SurfaceFactoryOzone::GetNativeDisplay() {
   return 0;
 }

-bool SurfaceFactoryOzone::SchedulePageFlip(gfx::AcceleratedWidget w) {
-  return true;
-}
-
-SkCanvas* SurfaceFactoryOzone::GetCanvasForWidget(gfx::AcceleratedWidget w) {
-  return NULL;
+scoped_ptr<SurfaceOzone> SurfaceFactoryOzone::CreateSurfaceForWidget(
+    gfx::AcceleratedWidget widget) {
+  NOTIMPLEMENTED();
+  return scoped_ptr<SurfaceOzone>();
 }

 const int32* SurfaceFactoryOzone::GetEGLSurfaceProperties(
diff --git a/ui/gfx/ozone/surface_factory_ozone.h b/ui/gfx/ozone/surface_factory_ozone.h
index fffdba6..50c7e89 100644
--- a/ui/gfx/ozone/surface_factory_ozone.h
+++ b/ui/gfx/ozone/surface_factory_ozone.h
@@ -20,6 +20,7 @@ class SkCanvas;
 namespace gfx {
 class VSyncProvider;
 class OverlayCandidatesOzone;
+class SurfaceOzone;
 typedef intptr_t NativeBufferOzone;

 // The Ozone interface allows external implementations to hook into Chromium to
@@ -109,11 +110,13 @@ class GFX_EXPORT SurfaceFactoryOzone {
   // before it can be used to create a GL surface.
   virtual gfx::AcceleratedWidget GetAcceleratedWidget() = 0;

-  // Realizes an AcceleratedWidget so that the returned AcceleratedWidget
-  // can be used to to create a GLSurface. This method may only be called in
-  // a process that has a valid GL context.
-  virtual gfx::AcceleratedWidget RealizeAcceleratedWidget(
-      gfx::AcceleratedWidget w) = 0;
+  // Create a surface for the specified gfx::AcceleratedWidget.
+  //
+  // Note: When used from content, this is called in the GPU process. The
+  // platform must support creation of SurfaceOzone from the GPU process
+  // using only the handle contained in gfx::AcceleratedWidget.
+  virtual scoped_ptr<SurfaceOzone> CreateSurfaceForWidget(
+      gfx::AcceleratedWidget widget);

   // Sets up GL bindings for the native surface. Takes two callback parameters
   // that allow Ozone to register the GL bindings.
@@ -121,31 +124,6 @@ class GFX_EXPORT SurfaceFactoryOzone {
       AddGLLibraryCallback add_gl_library,
       SetGLGetProcAddressProcCallback set_gl_get_proc_address) = 0;

-  // If possible attempts to resize the given AcceleratedWidget instance and if
-  // a resize action was performed returns true, otherwise false (native
-  // hardware may only support a single fixed size).
-  virtual bool AttemptToResizeAcceleratedWidget(
-      gfx::AcceleratedWidget w,
-      const gfx::Rect& bounds) = 0;
-
-  // Called after the appropriate GL swap buffers command. Used if extra work
-  // is needed to perform the actual buffer swap.
-  virtual bool SchedulePageFlip(gfx::AcceleratedWidget w);
-
-  // Returns a SkCanvas for the backing buffers. Drawing to the canvas will draw
-  // to the native surface. The canvas is intended for use when no EGL
-  // acceleration is possible. Its implementation is optional when an EGL
-  // backend is provided for rendering.
-  virtual SkCanvas* GetCanvasForWidget(gfx::AcceleratedWidget w);
-
-  // Returns a gfx::VsyncProvider for the provided AcceleratedWidget. Note
-  // that this may be called after we have entered the sandbox so if there are
-  // operations (e.g. opening a file descriptor providing vsync events) that
-  // must be done outside of the sandbox, they must have been completed
-  // in InitializeHardware. Returns an empty scoped_ptr on error.
-  virtual scoped_ptr<gfx::VSyncProvider> CreateVSyncProvider(
-      gfx::AcceleratedWidget w) = 0;
-
   // Returns an array of EGL properties, which can be used in any EGL function
   // used to select a display configuration. Note that all properties should be
   // immediately followed by the corresponding desired value and array should be
diff --git a/ui/gfx/ozone/surface_ozone.h b/ui/gfx/ozone/surface_ozone.h
new file mode 100644
index 0000000..dc3c64b
--- /dev/null
+++ b/ui/gfx/ozone/surface_ozone.h
@@ -0,0 +1,70 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_GFX_OZONE_SURFACE_OZONE_H_
+#define UI_GFX_OZONE_SURFACE_OZONE_H_
+
+#include "base/basictypes.h"
+#include "base/memory/scoped_ptr.h"
+#include "skia/ext/refptr.h"
+#include "ui/gfx/gfx_export.h"
+
+class SkCanvas;
+
+namespace gfx {
+
+class Size;
+class VSyncProvider;
+
+// The platform-specific part of an EGL surface or software output.
+//
+// This class owns any bits that the ozone implementation needs freed when
+// the software output or EGL surface is destroyed.
+//
+// If you want to paint on a window with ozone, you need to create a
+// SurfaceOzone for that window.
+//
+// The platform can support software, EGL, or both for painting on the
+// window. The initializer for unsupported modes should return false.
+class GFX_EXPORT SurfaceOzone {
+ public:
+  virtual ~SurfaceOzone() {}
+
+  // Initialize the surface for output using EGL/GLES2. Returns true if
+  // initialization was successful.
+  virtual bool InitializeEGL() = 0;
+
+  // Returns the EGL native window for rendering onto this surface.
+  // This can be used to to create a GLSurface.
+  virtual intptr_t /* EGLNativeWindowType */ GetEGLNativeWindow() = 0;
+
+  // Initialize canvas for software output. Returns true if initialization
+  // was successful.
+  virtual bool InitializeCanvas() = 0;
+
+  // Returns an SkCanvas for drawing on the window. The canvas is intended
+  // for use when no EGL/GLES2 acceleration is possible.
+  virtual skia::RefPtr<SkCanvas> GetCanvas() = 0;
+
+  // Attempts to resize the canvas to match the viewport size. Returns true if
+  // resizing was successful, otherwise false (platforms may require a fixed
+  // size canvas). After resizing, the compositor must call GetCanvas() to get
+  // the next canvas.
+  virtual bool ResizeCanvas(const gfx::Size& viewport_size) = 0;
+
+  // Present the current canvas. After presenting, the compositor must call
+  // GetCanvas() to get the next canvas.
+  virtual bool PresentCanvas() = 0;
+
+  // Returns a gfx::VsyncProvider for this surface. Note that this may be
+  // called after we have entered the sandbox so if there are operations (e.g.
+  // opening a file descriptor providing vsync events) that must be done
+  // outside of the sandbox, they must have been completed in
+  // InitializeHardware. Returns an empty scoped_ptr on error.
+  virtual scoped_ptr<gfx::VSyncProvider> CreateVSyncProvider() = 0;
+};
+
+}  // namespace gfx
+
+#endif  // UI_GFX_OZONE_SURFACE_OZONE_H_
diff --git a/ui/gfx/ozone/surface_ozone_base.cc b/ui/gfx/ozone/surface_ozone_base.cc
new file mode 100644
index 0000000..6793778
--- /dev/null
+++ b/ui/gfx/ozone/surface_ozone_base.cc
@@ -0,0 +1,45 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/gfx/ozone/surface_ozone_base.h"
+
+#include "third_party/skia/include/core/SkCanvas.h"
+#include "ui/gfx/vsync_provider.h"
+
+namespace gfx {
+
+SurfaceOzoneBase::SurfaceOzoneBase() {}
+
+SurfaceOzoneBase::~SurfaceOzoneBase() {}
+
+bool SurfaceOzoneBase::InitializeEGL() { return false; }
+
+intptr_t /* EGLNativeWindowType */ SurfaceOzoneBase::GetEGLNativeWindow() {
+  NOTREACHED();
+  return 0;
+}
+
+bool SurfaceOzoneBase::InitializeCanvas() { return false; }
+
+skia::RefPtr<SkCanvas> SurfaceOzoneBase::GetCanvas() {
+  NOTREACHED();
+  return skia::RefPtr<SkCanvas>();
+}
+
+bool SurfaceOzoneBase::ResizeCanvas(const gfx::Size& viewport_size) {
+  NOTIMPLEMENTED();
+  return false;
+}
+
+bool SurfaceOzoneBase::PresentCanvas() {
+  NOTIMPLEMENTED();
+  return true;
+}
+
+scoped_ptr<gfx::VSyncProvider> SurfaceOzoneBase::CreateVSyncProvider() {
+  NOTIMPLEMENTED();
+  return scoped_ptr<gfx::VSyncProvider>();
+}
+
+}  // namespace gfx
diff --git a/ui/gfx/ozone/surface_ozone_base.h b/ui/gfx/ozone/surface_ozone_base.h
new file mode 100644
index 0000000..0dbea40
--- /dev/null
+++ b/ui/gfx/ozone/surface_ozone_base.h
@@ -0,0 +1,41 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_GFX_OZONE_SURFACE_OZONE_BASE_H_
+#define UI_GFX_OZONE_SURFACE_OZONE_BASE_H_
+
+#include "base/basictypes.h"
+#include "base/memory/scoped_ptr.h"
+#include "skia/ext/refptr.h"
+#include "ui/gfx/gfx_export.h"
+#include "ui/gfx/ozone/surface_ozone.h"
+
+namespace gfx {
+
+// Base class for in-tree implementations of SurfaceOzone.
+//
+// This adds default implementations of all the methods in SurfaceOzone,
+// for use by in-tree subclasses.
+//
+// If an out-of-tree implementation inherits this, it is possible there
+// will be silent breakage instead of a compile time failure as a result
+// of changes to the interface.
+class GFX_EXPORT SurfaceOzoneBase : public SurfaceOzone {
+ public:
+  SurfaceOzoneBase();
+  virtual ~SurfaceOzoneBase() OVERRIDE;
+
+  // SurfaceOzone:
+  virtual bool InitializeEGL() OVERRIDE;
+  virtual intptr_t /* EGLNativeWindowType */ GetEGLNativeWindow() OVERRIDE;
+  virtual bool InitializeCanvas() OVERRIDE;
+  virtual skia::RefPtr<SkCanvas> GetCanvas() OVERRIDE;
+  virtual bool ResizeCanvas(const gfx::Size& viewport_size) OVERRIDE;
+  virtual bool PresentCanvas() OVERRIDE;
+  virtual scoped_ptr<gfx::VSyncProvider> CreateVSyncProvider() OVERRIDE;
+};
+
+}  // namespace gfx
+
+#endif  // UI_GFX_OZONE_SURFACE_OZONE_BASE_H_
diff --git a/ui/gl/gl_surface_ozone.cc b/ui/gl/gl_surface_ozone.cc
index 5e85723..63e6852 100644
--- a/ui/gl/gl_surface_ozone.cc
+++ b/ui/gl/gl_surface_ozone.cc
@@ -8,6 +8,7 @@
 #include "base/memory/ref_counted.h"
 #include "ui/gfx/native_widget_types.h"
 #include "ui/gfx/ozone/surface_factory_ozone.h"
+#include "ui/gfx/ozone/surface_ozone.h"
 #include "ui/gl/gl_implementation.h"
 #include "ui/gl/gl_surface_egl.h"
 #include "ui/gl/gl_surface_osmesa.h"
@@ -15,6 +16,28 @@

 namespace gfx {

+namespace {
+
+// A thin wrapper around GLSurfaceEGL that owns the EGLNativeWindow
+class GL_EXPORT GLSurfaceOzoneEGL : public NativeViewGLSurfaceEGL {
+ public:
+  GLSurfaceOzoneEGL(scoped_ptr<SurfaceOzone> ozone_surface)
+      : NativeViewGLSurfaceEGL(ozone_surface->GetEGLNativeWindow()),
+        ozone_surface_(ozone_surface.Pass()) {}
+
+  virtual ~GLSurfaceOzoneEGL() {
+    Destroy();  // EGL surface must be destroyed before SurfaceOzone
+  }
+
+ private:
+  // The native surface. Deleting this is allowed to free the EGLNativeWindow.
+  scoped_ptr<SurfaceOzone> ozone_surface_;
+
+  DISALLOW_COPY_AND_ASSIGN(GLSurfaceOzoneEGL);
+};
+
+}  // namespace
+
 // static
 bool GLSurface::InitializeOneOffInternal() {
   switch (GetGLImplementation()) {
@@ -46,16 +69,15 @@ scoped_refptr<GLSurface> GLSurface::CreateViewGLSurface(
   }
   DCHECK(GetGLImplementation() == kGLImplementationEGLGLES2);
   if (window != kNullAcceleratedWidget) {
-    EGLNativeWindowType egl_window =
-        gfx::SurfaceFactoryOzone::GetInstance()->RealizeAcceleratedWidget(
-            window);
-    scoped_ptr<VSyncProvider> sync_provider =
-        gfx::SurfaceFactoryOzone::GetInstance()->CreateVSyncProvider(
-            egl_window);
-    scoped_refptr<NativeViewGLSurfaceEGL> surface =
-        new NativeViewGLSurfaceEGL(egl_window);
-    if (surface->Initialize(sync_provider.Pass()))
-      return surface;
+    scoped_ptr<SurfaceOzone> surface_ozone =
+        SurfaceFactoryOzone::GetInstance()->CreateSurfaceForWidget(window);
+    if (!surface_ozone->InitializeEGL())
+      return NULL;
+    scoped_refptr<GLSurfaceOzoneEGL> surface =
+        new GLSurfaceOzoneEGL(surface_ozone.Pass());
+    if (!surface->Initialize(surface_ozone->CreateVSyncProvider()))
+      return NULL;
+    return surface;
   } else {
     scoped_refptr<GLSurface> surface = new GLSurfaceStub();
     if (surface->Initialize())
--
1.7.9.5
