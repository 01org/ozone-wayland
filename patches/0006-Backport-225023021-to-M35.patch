From 880af0ce7a66c9f3eb5e03d06fe36943b9fd0751 Mon Sep 17 00:00:00 2001
From: Kondapally Kalyan <kalyan.kondapally@intel.com>
Date: Fri, 16 May 2014 07:57:12 +0300
Subject: [PATCH 2/5] Backport 225023021 to M35

---
 .../compositor/software_output_device_ozone.cc     |    6 +-
 .../compositor/software_output_device_ozone.h      |    4 +-
 ui/gfx/gfx.gyp                                     |    5 +-
 ui/gfx/ozone/dri/dri_surface_factory.cc            |   18 +++--
 ui/gfx/ozone/dri/dri_surface_factory.h             |    5 +-
 ui/gfx/ozone/dri/dri_surface_factory_unittest.cc   |   13 ++--
 ui/gfx/ozone/impl/file_surface_factory.cc          |   14 ++--
 ui/gfx/ozone/impl/file_surface_factory.h           |    4 +-
 ui/gfx/ozone/surface_factory_ozone.cc              |   15 +++--
 ui/gfx/ozone/surface_factory_ozone.h               |   24 +++++--
 ui/gfx/ozone/surface_ozone.h                       |   70 --------------------
 ui/gfx/ozone/surface_ozone_base.cc                 |   45 -------------
 ui/gfx/ozone/surface_ozone_base.h                  |   41 ------------
 ui/gfx/ozone/surface_ozone_canvas.h                |   51 ++++++++++++++
 ui/gfx/ozone/surface_ozone_egl.h                   |   43 ++++++++++++
 ui/gl/gl_surface_ozone.cc                          |   14 ++--
 16 files changed, 168 insertions(+), 204 deletions(-)
 delete mode 100644 ui/gfx/ozone/surface_ozone.h
 delete mode 100644 ui/gfx/ozone/surface_ozone_base.cc
 delete mode 100644 ui/gfx/ozone/surface_ozone_base.h
 create mode 100644 ui/gfx/ozone/surface_ozone_canvas.h
 create mode 100644 ui/gfx/ozone/surface_ozone_egl.h

diff --git a/content/browser/compositor/software_output_device_ozone.cc b/content/browser/compositor/software_output_device_ozone.cc
index 44b5e1b..dfc4c5e 100644
--- a/content/browser/compositor/software_output_device_ozone.cc
+++ b/content/browser/compositor/software_output_device_ozone.cc
@@ -6,7 +6,7 @@
 #include "third_party/skia/include/core/SkDevice.h"
 #include "ui/compositor/compositor.h"
 #include "ui/gfx/ozone/surface_factory_ozone.h"
-#include "ui/gfx/ozone/surface_ozone.h"
+#include "ui/gfx/ozone/surface_ozone_canvas.h"
 #include "ui/gfx/skia_util.h"
 #include "ui/gfx/vsync_provider.h"

@@ -19,9 +19,9 @@ SoftwareOutputDeviceOzone::SoftwareOutputDeviceOzone(ui::Compositor* compositor)
   if (factory->InitializeHardware() != gfx::SurfaceFactoryOzone::INITIALIZED)
     LOG(FATAL) << "Failed to initialize hardware in OZONE";

-  surface_ozone_ = factory->CreateSurfaceForWidget(compositor_->widget());
+  surface_ozone_ = factory->CreateCanvasForWidget(compositor_->widget());

-  if (!surface_ozone_->InitializeCanvas())
+  if (!surface_ozone_)
     LOG(FATAL) << "Failed to initialize canvas";

   vsync_provider_ = surface_ozone_->CreateVSyncProvider();
diff --git a/content/browser/compositor/software_output_device_ozone.h b/content/browser/compositor/software_output_device_ozone.h
index 46014e6..07a6170 100644
--- a/content/browser/compositor/software_output_device_ozone.h
+++ b/content/browser/compositor/software_output_device_ozone.h
@@ -14,7 +14,7 @@ class Compositor;
 }

 namespace gfx {
-class SurfaceOzone;
+class SurfaceOzoneCanvas;
 }

 namespace content {
@@ -35,7 +35,7 @@ class CONTENT_EXPORT SoftwareOutputDeviceOzone
  private:
   ui::Compositor* compositor_;

-  scoped_ptr<gfx::SurfaceOzone> surface_ozone_;
+  scoped_ptr<gfx::SurfaceOzoneCanvas> surface_ozone_;

   DISALLOW_COPY_AND_ASSIGN(SoftwareOutputDeviceOzone);
 };
diff --git a/ui/gfx/gfx.gyp b/ui/gfx/gfx.gyp
index 4235c39..dff0d39 100644
--- a/ui/gfx/gfx.gyp
+++ b/ui/gfx/gfx.gyp
@@ -218,9 +218,8 @@
         'ozone/impl/file_surface_factory.h',
         'ozone/surface_factory_ozone.cc',
         'ozone/surface_factory_ozone.h',
-        'ozone/surface_ozone_base.cc',
-        'ozone/surface_ozone_base.h',
-        'ozone/surface_ozone.h',
+        'ozone/surface_ozone_egl.h',
+        'ozone/surface_ozone_canvas.h',
         'ozone/overlay_candidates_ozone.cc',
         'ozone/overlay_candidates_ozone.h',
         'pango_util.cc',
diff --git a/ui/gfx/ozone/dri/dri_surface_factory.cc b/ui/gfx/ozone/dri/dri_surface_factory.cc
index a6be37f..0f7741e 100644
--- a/ui/gfx/ozone/dri/dri_surface_factory.cc
+++ b/ui/gfx/ozone/dri/dri_surface_factory.cc
@@ -17,7 +17,7 @@
 #include "ui/gfx/ozone/dri/dri_vsync_provider.h"
 #include "ui/gfx/ozone/dri/dri_wrapper.h"
 #include "ui/gfx/ozone/dri/hardware_display_controller.h"
-#include "ui/gfx/ozone/surface_ozone_base.h"
+#include "ui/gfx/ozone/surface_ozone_canvas.h"

 namespace gfx {

@@ -123,7 +123,7 @@ void UpdateCursorImage(DriSurface* cursor, const SkBitmap& image) {
 // the compositor merely owns this proxy object.
 //
 // TODO(spang): Should the compositor own any bits of the DriSurface?
-class DriSurfaceAdapter : public SurfaceOzoneBase {
+class DriSurfaceAdapter : public SurfaceOzoneCanvas {
  public:
   DriSurfaceAdapter(gfx::AcceleratedWidget w, DriSurfaceFactory* dri)
       : widget_(w), dri_(dri) {}
@@ -134,6 +134,10 @@ class DriSurfaceAdapter : public SurfaceOzoneBase {
   virtual skia::RefPtr<SkCanvas> GetCanvas() OVERRIDE {
     return skia::SharePtr(dri_->GetCanvasForWidget(widget_));
   }
+  virtual bool ResizeCanvas(const gfx::Size& viewport_size) OVERRIDE {
+    NOTIMPLEMENTED();
+    return false;
+  }
   virtual bool PresentCanvas() OVERRIDE {
     return dri_->SchedulePageFlip(widget_);
   }
@@ -208,7 +212,7 @@ gfx::AcceleratedWidget DriSurfaceFactory::GetAcceleratedWidget() {
   return kDefaultWidgetHandle;
 }

-scoped_ptr<SurfaceOzone> DriSurfaceFactory::CreateSurfaceForWidget(
+scoped_ptr<SurfaceOzoneCanvas> DriSurfaceFactory::CreateCanvasForWidget(
     gfx::AcceleratedWidget w) {
   CHECK(state_ == INITIALIZED);
   // TODO(dnicoara) Once we can handle multiple displays this needs to be
@@ -222,7 +226,7 @@ scoped_ptr<SurfaceOzone> DriSurfaceFactory::CreateSurfaceForWidget(
   // hardware display.
   if (!InitializeControllerForPrimaryDisplay(drm_.get(), controller_.get())) {
     LOG(ERROR) << "Failed to initialize controller";
-    return scoped_ptr<SurfaceOzone>();
+    return scoped_ptr<SurfaceOzoneCanvas>();
   }

   // Create a surface suitable for the current controller.
@@ -232,7 +236,7 @@ scoped_ptr<SurfaceOzone> DriSurfaceFactory::CreateSurfaceForWidget(

   if (!surface->Initialize()) {
     LOG(ERROR) << "Failed to initialize surface";
-    return scoped_ptr<SurfaceOzone>();
+    return scoped_ptr<SurfaceOzoneCanvas>();
   }

   // Bind the surface to the controller. This will register the backing buffers
@@ -240,13 +244,13 @@ scoped_ptr<SurfaceOzone> DriSurfaceFactory::CreateSurfaceForWidget(
   // takes ownership of the surface.
   if (!controller_->BindSurfaceToController(surface.Pass())) {
     LOG(ERROR) << "Failed to bind surface to controller";
-    return scoped_ptr<SurfaceOzone>();
+    return scoped_ptr<SurfaceOzoneCanvas>();
   }

   // Initial cursor set.
   ResetCursor();

-  return make_scoped_ptr<SurfaceOzone>(new DriSurfaceAdapter(w, this));
+  return make_scoped_ptr<SurfaceOzoneCanvas>(new DriSurfaceAdapter(w, this));
 }

 bool DriSurfaceFactory::LoadEGLGLES2Bindings(
diff --git a/ui/gfx/ozone/dri/dri_surface_factory.h b/ui/gfx/ozone/dri/dri_surface_factory.h
index 34f2bdd..993dc07 100644
--- a/ui/gfx/ozone/dri/dri_surface_factory.h
+++ b/ui/gfx/ozone/dri/dri_surface_factory.h
@@ -8,14 +8,13 @@
 #include "base/memory/scoped_ptr.h"
 #include "third_party/skia/include/core/SkBitmap.h"
 #include "ui/gfx/ozone/surface_factory_ozone.h"
-#include "ui/gfx/ozone/surface_ozone.h"

 namespace gfx {

 class DriSurface;
 class DriWrapper;
 class HardwareDisplayController;
-class SurfaceOzone;
+class SurfaceOzoneCanvas;

 // SurfaceFactoryOzone implementation on top of DRM/KMS using dumb buffers.
 // This implementation is used in conjunction with the software rendering
@@ -30,7 +29,7 @@ class GFX_EXPORT DriSurfaceFactory : public SurfaceFactoryOzone {

   virtual gfx::AcceleratedWidget GetAcceleratedWidget() OVERRIDE;

-  virtual scoped_ptr<SurfaceOzone> CreateSurfaceForWidget(
+  virtual scoped_ptr<SurfaceOzoneCanvas> CreateCanvasForWidget(
       gfx::AcceleratedWidget w) OVERRIDE;

   virtual bool LoadEGLGLES2Bindings(
diff --git a/ui/gfx/ozone/dri/dri_surface_factory_unittest.cc b/ui/gfx/ozone/dri/dri_surface_factory_unittest.cc
index 1c1fb3f..6b76314 100644
--- a/ui/gfx/ozone/dri/dri_surface_factory_unittest.cc
+++ b/ui/gfx/ozone/dri/dri_surface_factory_unittest.cc
@@ -14,6 +14,7 @@
 #include "ui/gfx/ozone/dri/dri_wrapper.h"
 #include "ui/gfx/ozone/dri/hardware_display_controller.h"
 #include "ui/gfx/ozone/surface_factory_ozone.h"
+#include "ui/gfx/ozone/surface_ozone_canvas.h"

 namespace {

@@ -263,7 +264,7 @@ TEST_F(DriSurfaceFactoryTest, FailSurfaceInitialization) {
   gfx::AcceleratedWidget w = factory_->GetAcceleratedWidget();
   EXPECT_EQ(kDefaultWidgetHandle, w);

-  EXPECT_FALSE(factory_->CreateSurfaceForWidget(w));
+  EXPECT_FALSE(factory_->CreateCanvasForWidget(w));
 }

 TEST_F(DriSurfaceFactoryTest, FailBindingSurfaceToController) {
@@ -275,7 +276,7 @@ TEST_F(DriSurfaceFactoryTest, FailBindingSurfaceToController) {
   gfx::AcceleratedWidget w = factory_->GetAcceleratedWidget();
   EXPECT_EQ(kDefaultWidgetHandle, w);

-  EXPECT_FALSE(factory_->CreateSurfaceForWidget(w));
+  EXPECT_FALSE(factory_->CreateCanvasForWidget(w));
 }

 TEST_F(DriSurfaceFactoryTest, SuccessfulWidgetRealization) {
@@ -285,7 +286,7 @@ TEST_F(DriSurfaceFactoryTest, SuccessfulWidgetRealization) {
   gfx::AcceleratedWidget w = factory_->GetAcceleratedWidget();
   EXPECT_EQ(kDefaultWidgetHandle, w);

-  EXPECT_TRUE(factory_->CreateSurfaceForWidget(w));
+  EXPECT_TRUE(factory_->CreateCanvasForWidget(w));
 }

 TEST_F(DriSurfaceFactoryTest, FailSchedulePageFlip) {
@@ -297,7 +298,7 @@ TEST_F(DriSurfaceFactoryTest, FailSchedulePageFlip) {
   gfx::AcceleratedWidget w = factory_->GetAcceleratedWidget();
   EXPECT_EQ(kDefaultWidgetHandle, w);

-  scoped_ptr<gfx::SurfaceOzone> surf = factory_->CreateSurfaceForWidget(w);
+  scoped_ptr<gfx::SurfaceOzoneCanvas> surf = factory_->CreateCanvasForWidget(w);
   EXPECT_TRUE(surf);

   EXPECT_FALSE(factory_->SchedulePageFlip(w));
@@ -310,7 +311,7 @@ TEST_F(DriSurfaceFactoryTest, SuccessfulSchedulePageFlip) {
   gfx::AcceleratedWidget w = factory_->GetAcceleratedWidget();
   EXPECT_EQ(kDefaultWidgetHandle, w);

-  scoped_ptr<gfx::SurfaceOzone> surf = factory_->CreateSurfaceForWidget(w);
+  scoped_ptr<gfx::SurfaceOzoneCanvas> surf = factory_->CreateCanvasForWidget(w);
   EXPECT_TRUE(surf);

   EXPECT_TRUE(factory_->SchedulePageFlip(w));
@@ -323,7 +324,7 @@ TEST_F(DriSurfaceFactoryTest, SetCursorImage) {
   gfx::AcceleratedWidget w = factory_->GetAcceleratedWidget();
   EXPECT_EQ(kDefaultWidgetHandle, w);

-  scoped_ptr<gfx::SurfaceOzone> surf = factory_->CreateSurfaceForWidget(w);
+  scoped_ptr<gfx::SurfaceOzoneCanvas> surf = factory_->CreateCanvasForWidget(w);
   EXPECT_TRUE(surf);

   SkBitmap image;
diff --git a/ui/gfx/ozone/impl/file_surface_factory.cc b/ui/gfx/ozone/impl/file_surface_factory.cc
index c42be60..bf097ac 100644
--- a/ui/gfx/ozone/impl/file_surface_factory.cc
+++ b/ui/gfx/ozone/impl/file_surface_factory.cc
@@ -12,7 +12,7 @@
 #include "third_party/skia/include/core/SkBitmapDevice.h"
 #include "third_party/skia/include/core/SkDevice.h"
 #include "ui/gfx/codec/png_codec.h"
-#include "ui/gfx/ozone/surface_ozone_base.h"
+#include "ui/gfx/ozone/surface_ozone_canvas.h"
 #include "ui/gfx/skia_util.h"
 #include "ui/gfx/vsync_provider.h"

@@ -29,7 +29,7 @@ void WriteDataToFile(const base::FilePath& location,
                   png_data.size());
 }

-class FileSurface : public SurfaceOzoneBase {
+class FileSurface : public SurfaceOzoneCanvas {
  public:
   FileSurface(const base::FilePath& location) : location_(location) {}
   virtual ~FileSurface() {}
@@ -58,6 +58,10 @@ class FileSurface : public SurfaceOzoneBase {
     return true;
   }

+  virtual scoped_ptr<gfx::VSyncProvider> CreateVSyncProvider() OVERRIDE {
+    return scoped_ptr<gfx::VSyncProvider>();
+  }
+
  private:
   base::FilePath location_;
   skia::RefPtr<SkBitmapDevice> device_;
@@ -88,9 +92,9 @@ AcceleratedWidget FileSurfaceFactory::GetAcceleratedWidget() {
   return 1;
 }

-scoped_ptr<SurfaceOzone> FileSurfaceFactory::CreateSurfaceForWidget(
-    AcceleratedWidget widget) {
-  return make_scoped_ptr<SurfaceOzone>(new FileSurface(location_));
+scoped_ptr<SurfaceOzoneCanvas> FileSurfaceFactory::CreateCanvasForWidget(
+      gfx::AcceleratedWidget w) {
+  return make_scoped_ptr<SurfaceOzoneCanvas>(new FileSurface(location_));
 }

 bool FileSurfaceFactory::LoadEGLGLES2Bindings(
diff --git a/ui/gfx/ozone/impl/file_surface_factory.h b/ui/gfx/ozone/impl/file_surface_factory.h
index 11f937c..2da6748 100644
--- a/ui/gfx/ozone/impl/file_surface_factory.h
+++ b/ui/gfx/ozone/impl/file_surface_factory.h
@@ -25,8 +25,8 @@ class GFX_EXPORT FileSurfaceFactory : public SurfaceFactoryOzone {
   virtual HardwareState InitializeHardware() OVERRIDE;
   virtual void ShutdownHardware() OVERRIDE;
   virtual AcceleratedWidget GetAcceleratedWidget() OVERRIDE;
-  virtual scoped_ptr<SurfaceOzone> CreateSurfaceForWidget(
-      AcceleratedWidget widget) OVERRIDE;
+  virtual scoped_ptr<SurfaceOzoneCanvas> CreateCanvasForWidget(
+      gfx::AcceleratedWidget w) OVERRIDE;
   virtual bool LoadEGLGLES2Bindings(
       AddGLLibraryCallback add_gl_library,
       SetGLGetProcAddressProcCallback set_gl_get_proc_address) OVERRIDE;
diff --git a/ui/gfx/ozone/surface_factory_ozone.cc b/ui/gfx/ozone/surface_factory_ozone.cc
index a678fa8..84e7a0a 100644
--- a/ui/gfx/ozone/surface_factory_ozone.cc
+++ b/ui/gfx/ozone/surface_factory_ozone.cc
@@ -7,7 +7,8 @@
 #include <stdlib.h>

 #include "base/command_line.h"
-#include "ui/gfx/ozone/surface_ozone.h"
+#include "ui/gfx/ozone/surface_ozone_canvas.h"
+#include "ui/gfx/ozone/surface_ozone_egl.h"

 namespace gfx {

@@ -33,10 +34,16 @@ intptr_t SurfaceFactoryOzone::GetNativeDisplay() {
   return 0;
 }

-scoped_ptr<SurfaceOzone> SurfaceFactoryOzone::CreateSurfaceForWidget(
-    gfx::AcceleratedWidget widget) {
+scoped_ptr<SurfaceOzoneEGL> SurfaceFactoryOzone::CreateEGLSurfaceForWidget(
+      gfx::AcceleratedWidget widget) {
   NOTIMPLEMENTED();
-  return scoped_ptr<SurfaceOzone>();
+  return scoped_ptr<SurfaceOzoneEGL>();
+}
+
+scoped_ptr<SurfaceOzoneCanvas> SurfaceFactoryOzone::CreateCanvasForWidget(
+      gfx::AcceleratedWidget widget) {
+  NOTIMPLEMENTED();
+  return scoped_ptr<SurfaceOzoneCanvas>();
 }

 const int32* SurfaceFactoryOzone::GetEGLSurfaceProperties(
diff --git a/ui/gfx/ozone/surface_factory_ozone.h b/ui/gfx/ozone/surface_factory_ozone.h
index 50c7e89..5929041 100644
--- a/ui/gfx/ozone/surface_factory_ozone.h
+++ b/ui/gfx/ozone/surface_factory_ozone.h
@@ -20,7 +20,8 @@ class SkCanvas;
 namespace gfx {
 class VSyncProvider;
 class OverlayCandidatesOzone;
-class SurfaceOzone;
+class SurfaceOzoneCanvas;
+class SurfaceOzoneEGL;
 typedef intptr_t NativeBufferOzone;

 // The Ozone interface allows external implementations to hook into Chromium to
@@ -28,6 +29,9 @@ typedef intptr_t NativeBufferOzone;
 // drawing modes: 1) accelerated drawing through EGL and 2) software drawing
 // through Skia.
 //
+// If you want to paint on a window with ozone, you need to create a
+// SurfaceOzoneEGL or SurfaceOzoneCanvas for that window. The platform can
+// support software, EGL, or both for painting on the window.
 // The following functionality is specific to the drawing mode and may not have
 // any meaningful implementation in the other mode. An implementation must
 // provide functionality for at least one mode.
@@ -39,11 +43,12 @@ typedef intptr_t NativeBufferOzone;
 //  - LoadEGLGLES2Bindings
 //  - GetEGLSurfaceProperties (optional if the properties match the default
 //  Chromium ones).
+//  - CreateEGLSurfaceForWidget
 //
 // 2) Software Drawing (Skia):
 //
 // The following function is specific to the software path:
-//  - GetCanvasForWidget
+//  - CreateCanvasForWidget
 //
 // The accelerated path can optionally provide support for the software drawing
 // path.
@@ -110,13 +115,20 @@ class GFX_EXPORT SurfaceFactoryOzone {
   // before it can be used to create a GL surface.
   virtual gfx::AcceleratedWidget GetAcceleratedWidget() = 0;

-  // Create a surface for the specified gfx::AcceleratedWidget.
+  // Create SurfaceOzoneEGL for the specified gfx::AcceleratedWidget.
   //
   // Note: When used from content, this is called in the GPU process. The
-  // platform must support creation of SurfaceOzone from the GPU process
+  // platform must support creation of SurfaceOzoneEGL from the GPU process
   // using only the handle contained in gfx::AcceleratedWidget.
-  virtual scoped_ptr<SurfaceOzone> CreateSurfaceForWidget(
-      gfx::AcceleratedWidget widget);
+  virtual scoped_ptr<SurfaceOzoneEGL> CreateEGLSurfaceForWidget(
+        gfx::AcceleratedWidget widget);
+
+  // Create SurfaceOzoneCanvas for the specified gfx::AcceleratedWidget.
+  //
+  // Note: The platform must support creation of SurfaceOzoneCanvas from the
+  // Browser Process using only the handle contained in gfx::AcceleratedWidget.
+  virtual scoped_ptr<SurfaceOzoneCanvas> CreateCanvasForWidget(
+        gfx::AcceleratedWidget widget);

   // Sets up GL bindings for the native surface. Takes two callback parameters
   // that allow Ozone to register the GL bindings.
diff --git a/ui/gfx/ozone/surface_ozone.h b/ui/gfx/ozone/surface_ozone.h
deleted file mode 100644
index dc3c64b..0000000
--- a/ui/gfx/ozone/surface_ozone.h
+++ /dev/null
@@ -1,70 +0,0 @@
-// Copyright 2014 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef UI_GFX_OZONE_SURFACE_OZONE_H_
-#define UI_GFX_OZONE_SURFACE_OZONE_H_
-
-#include "base/basictypes.h"
-#include "base/memory/scoped_ptr.h"
-#include "skia/ext/refptr.h"
-#include "ui/gfx/gfx_export.h"
-
-class SkCanvas;
-
-namespace gfx {
-
-class Size;
-class VSyncProvider;
-
-// The platform-specific part of an EGL surface or software output.
-//
-// This class owns any bits that the ozone implementation needs freed when
-// the software output or EGL surface is destroyed.
-//
-// If you want to paint on a window with ozone, you need to create a
-// SurfaceOzone for that window.
-//
-// The platform can support software, EGL, or both for painting on the
-// window. The initializer for unsupported modes should return false.
-class GFX_EXPORT SurfaceOzone {
- public:
-  virtual ~SurfaceOzone() {}
-
-  // Initialize the surface for output using EGL/GLES2. Returns true if
-  // initialization was successful.
-  virtual bool InitializeEGL() = 0;
-
-  // Returns the EGL native window for rendering onto this surface.
-  // This can be used to to create a GLSurface.
-  virtual intptr_t /* EGLNativeWindowType */ GetEGLNativeWindow() = 0;
-
-  // Initialize canvas for software output. Returns true if initialization
-  // was successful.
-  virtual bool InitializeCanvas() = 0;
-
-  // Returns an SkCanvas for drawing on the window. The canvas is intended
-  // for use when no EGL/GLES2 acceleration is possible.
-  virtual skia::RefPtr<SkCanvas> GetCanvas() = 0;
-
-  // Attempts to resize the canvas to match the viewport size. Returns true if
-  // resizing was successful, otherwise false (platforms may require a fixed
-  // size canvas). After resizing, the compositor must call GetCanvas() to get
-  // the next canvas.
-  virtual bool ResizeCanvas(const gfx::Size& viewport_size) = 0;
-
-  // Present the current canvas. After presenting, the compositor must call
-  // GetCanvas() to get the next canvas.
-  virtual bool PresentCanvas() = 0;
-
-  // Returns a gfx::VsyncProvider for this surface. Note that this may be
-  // called after we have entered the sandbox so if there are operations (e.g.
-  // opening a file descriptor providing vsync events) that must be done
-  // outside of the sandbox, they must have been completed in
-  // InitializeHardware. Returns an empty scoped_ptr on error.
-  virtual scoped_ptr<gfx::VSyncProvider> CreateVSyncProvider() = 0;
-};
-
-}  // namespace gfx
-
-#endif  // UI_GFX_OZONE_SURFACE_OZONE_H_
diff --git a/ui/gfx/ozone/surface_ozone_base.cc b/ui/gfx/ozone/surface_ozone_base.cc
deleted file mode 100644
index 6793778..0000000
--- a/ui/gfx/ozone/surface_ozone_base.cc
+++ /dev/null
@@ -1,45 +0,0 @@
-// Copyright 2014 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "ui/gfx/ozone/surface_ozone_base.h"
-
-#include "third_party/skia/include/core/SkCanvas.h"
-#include "ui/gfx/vsync_provider.h"
-
-namespace gfx {
-
-SurfaceOzoneBase::SurfaceOzoneBase() {}
-
-SurfaceOzoneBase::~SurfaceOzoneBase() {}
-
-bool SurfaceOzoneBase::InitializeEGL() { return false; }
-
-intptr_t /* EGLNativeWindowType */ SurfaceOzoneBase::GetEGLNativeWindow() {
-  NOTREACHED();
-  return 0;
-}
-
-bool SurfaceOzoneBase::InitializeCanvas() { return false; }
-
-skia::RefPtr<SkCanvas> SurfaceOzoneBase::GetCanvas() {
-  NOTREACHED();
-  return skia::RefPtr<SkCanvas>();
-}
-
-bool SurfaceOzoneBase::ResizeCanvas(const gfx::Size& viewport_size) {
-  NOTIMPLEMENTED();
-  return false;
-}
-
-bool SurfaceOzoneBase::PresentCanvas() {
-  NOTIMPLEMENTED();
-  return true;
-}
-
-scoped_ptr<gfx::VSyncProvider> SurfaceOzoneBase::CreateVSyncProvider() {
-  NOTIMPLEMENTED();
-  return scoped_ptr<gfx::VSyncProvider>();
-}
-
-}  // namespace gfx
diff --git a/ui/gfx/ozone/surface_ozone_base.h b/ui/gfx/ozone/surface_ozone_base.h
deleted file mode 100644
index 0dbea40..0000000
--- a/ui/gfx/ozone/surface_ozone_base.h
+++ /dev/null
@@ -1,41 +0,0 @@
-// Copyright 2014 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef UI_GFX_OZONE_SURFACE_OZONE_BASE_H_
-#define UI_GFX_OZONE_SURFACE_OZONE_BASE_H_
-
-#include "base/basictypes.h"
-#include "base/memory/scoped_ptr.h"
-#include "skia/ext/refptr.h"
-#include "ui/gfx/gfx_export.h"
-#include "ui/gfx/ozone/surface_ozone.h"
-
-namespace gfx {
-
-// Base class for in-tree implementations of SurfaceOzone.
-//
-// This adds default implementations of all the methods in SurfaceOzone,
-// for use by in-tree subclasses.
-//
-// If an out-of-tree implementation inherits this, it is possible there
-// will be silent breakage instead of a compile time failure as a result
-// of changes to the interface.
-class GFX_EXPORT SurfaceOzoneBase : public SurfaceOzone {
- public:
-  SurfaceOzoneBase();
-  virtual ~SurfaceOzoneBase() OVERRIDE;
-
-  // SurfaceOzone:
-  virtual bool InitializeEGL() OVERRIDE;
-  virtual intptr_t /* EGLNativeWindowType */ GetEGLNativeWindow() OVERRIDE;
-  virtual bool InitializeCanvas() OVERRIDE;
-  virtual skia::RefPtr<SkCanvas> GetCanvas() OVERRIDE;
-  virtual bool ResizeCanvas(const gfx::Size& viewport_size) OVERRIDE;
-  virtual bool PresentCanvas() OVERRIDE;
-  virtual scoped_ptr<gfx::VSyncProvider> CreateVSyncProvider() OVERRIDE;
-};
-
-}  // namespace gfx
-
-#endif  // UI_GFX_OZONE_SURFACE_OZONE_BASE_H_
diff --git a/ui/gfx/ozone/surface_ozone_canvas.h b/ui/gfx/ozone/surface_ozone_canvas.h
new file mode 100644
index 0000000..7b09b23
--- /dev/null
+++ b/ui/gfx/ozone/surface_ozone_canvas.h
@@ -0,0 +1,51 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_GFX_OZONE_SURFACE_OZONE_CANVAS_H_
+#define UI_GFX_OZONE_SURFACE_OZONE_CANVAS_H_
+
+#include "base/basictypes.h"
+#include "base/memory/scoped_ptr.h"
+#include "skia/ext/refptr.h"
+#include "ui/gfx/gfx_export.h"
+
+class SkCanvas;
+
+namespace gfx {
+
+class Size;
+class VSyncProvider;
+
+// The platform-specific part of an software output. The class is intended
+// for use when no EGL/GLES2 acceleration is possible.
+// This class owns any bits that the ozone implementation needs freed when
+// the software output is destroyed.
+class GFX_EXPORT SurfaceOzoneCanvas {
+ public:
+  virtual ~SurfaceOzoneCanvas() {}
+
+  // Returns an SkCanvas for drawing on the window.
+  virtual skia::RefPtr<SkCanvas> GetCanvas() = 0;
+
+  // Attempts to resize the canvas to match the viewport size. Returns true if
+  // resizing was successful, otherwise false (platforms may require a fixed
+  // size canvas). After resizing, the compositor must call GetCanvas() to get
+  // the next canvas.
+  virtual bool ResizeCanvas(const gfx::Size& viewport_size) = 0;
+
+  // Present the current canvas. After presenting, the compositor must call
+  // GetCanvas() to get the next canvas.
+  virtual bool PresentCanvas() = 0;
+
+  // Returns a gfx::VsyncProvider for this surface. Note that this may be
+  // called after we have entered the sandbox so if there are operations (e.g.
+  // opening a file descriptor providing vsync events) that must be done
+  // outside of the sandbox, they must have been completed in
+  // InitializeHardware. Returns an empty scoped_ptr on error.
+  virtual scoped_ptr<gfx::VSyncProvider> CreateVSyncProvider() = 0;
+};
+
+}  // namespace gfx
+
+#endif  // UI_GFX_OZONE_SURFACE_OZONE_CANVAS_H_
diff --git a/ui/gfx/ozone/surface_ozone_egl.h b/ui/gfx/ozone/surface_ozone_egl.h
new file mode 100644
index 0000000..7dd89fb
--- /dev/null
+++ b/ui/gfx/ozone/surface_ozone_egl.h
@@ -0,0 +1,43 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_GFX_OZONE_SURFACE_OZONE_EGL_H_
+#define UI_GFX_OZONE_SURFACE_OZONE_EGL_H_
+
+#include "base/basictypes.h"
+#include "base/memory/scoped_ptr.h"
+#include "ui/gfx/gfx_export.h"
+
+namespace gfx {
+
+class Size;
+class VSyncProvider;
+
+// The platform-specific part of an EGL surface.
+//
+// This class owns any bits that the ozone implementation needs freed when
+// the EGL surface is destroyed.
+class GFX_EXPORT SurfaceOzoneEGL {
+ public:
+  virtual ~SurfaceOzoneEGL() {}
+
+  // Returns the EGL native window for rendering onto this surface.
+  // This can be used to to create a GLSurface.
+  virtual intptr_t /* EGLNativeWindowType */ GetNativeWindow() = 0;
+
+  // Attempts to resize the EGL native window to match the viewport
+  // size.
+  virtual bool ResizeNativeWindow(const gfx::Size& viewport_size) = 0;
+
+  // Returns a gfx::VsyncProvider for this surface. Note that this may be
+  // called after we have entered the sandbox so if there are operations (e.g.
+  // opening a file descriptor providing vsync events) that must be done
+  // outside of the sandbox, they must have been completed in
+  // InitializeHardware. Returns an empty scoped_ptr on error.
+  virtual scoped_ptr<gfx::VSyncProvider> CreateVSyncProvider() = 0;
+};
+
+}  // namespace gfx
+
+#endif  // UI_GFX_OZONE_SURFACE_OZONE_EGL_H_
diff --git a/ui/gl/gl_surface_ozone.cc b/ui/gl/gl_surface_ozone.cc
index 63e6852..9af032b 100644
--- a/ui/gl/gl_surface_ozone.cc
+++ b/ui/gl/gl_surface_ozone.cc
@@ -8,7 +8,7 @@
 #include "base/memory/ref_counted.h"
 #include "ui/gfx/native_widget_types.h"
 #include "ui/gfx/ozone/surface_factory_ozone.h"
-#include "ui/gfx/ozone/surface_ozone.h"
+#include "ui/gfx/ozone/surface_ozone_egl.h"
 #include "ui/gl/gl_implementation.h"
 #include "ui/gl/gl_surface_egl.h"
 #include "ui/gl/gl_surface_osmesa.h"
@@ -21,8 +21,8 @@ namespace {
 // A thin wrapper around GLSurfaceEGL that owns the EGLNativeWindow
 class GL_EXPORT GLSurfaceOzoneEGL : public NativeViewGLSurfaceEGL {
  public:
-  GLSurfaceOzoneEGL(scoped_ptr<SurfaceOzone> ozone_surface)
-      : NativeViewGLSurfaceEGL(ozone_surface->GetEGLNativeWindow()),
+  GLSurfaceOzoneEGL(scoped_ptr<SurfaceOzoneEGL> ozone_surface)
+      : NativeViewGLSurfaceEGL(ozone_surface->GetNativeWindow()),
         ozone_surface_(ozone_surface.Pass()) {}

   virtual ~GLSurfaceOzoneEGL() {
@@ -31,7 +31,7 @@ class GL_EXPORT GLSurfaceOzoneEGL : public NativeViewGLSurfaceEGL {

  private:
   // The native surface. Deleting this is allowed to free the EGLNativeWindow.
-  scoped_ptr<SurfaceOzone> ozone_surface_;
+  scoped_ptr<SurfaceOzoneEGL> ozone_surface_;

   DISALLOW_COPY_AND_ASSIGN(GLSurfaceOzoneEGL);
 };
@@ -69,9 +69,9 @@ scoped_refptr<GLSurface> GLSurface::CreateViewGLSurface(
   }
   DCHECK(GetGLImplementation() == kGLImplementationEGLGLES2);
   if (window != kNullAcceleratedWidget) {
-    scoped_ptr<SurfaceOzone> surface_ozone =
-        SurfaceFactoryOzone::GetInstance()->CreateSurfaceForWidget(window);
-    if (!surface_ozone->InitializeEGL())
+    scoped_ptr<SurfaceOzoneEGL> surface_ozone =
+        SurfaceFactoryOzone::GetInstance()->CreateEGLSurfaceForWidget(window);
+    if (!surface_ozone)
       return NULL;
     scoped_refptr<GLSurfaceOzoneEGL> surface =
         new GLSurfaceOzoneEGL(surface_ozone.Pass());
--
1.7.9.5
